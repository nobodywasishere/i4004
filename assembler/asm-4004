#!/usr/bin/env python

import os, sys
import argparse

####################################################################################################
####################################################################################################

# instructions supported by the 4004
instr = {
        'nop': [0x0, 0x0],
        'jcn': [0x1],
        'jnt': [0x1, 0x1],
        'jc' : [0x1, 0x2],
        'jz' : [0x1, 0x4],
        'jt' : [0x1, 0x9],
        'jnc': [0x1, 0xA],
        'jnz': [0x1, 0xC],
        'fim': [0x2],
        'src': [0x2],
        'fin': [0x3],
        'jin': [0x3],
        'jun': [0x4],
        'jms': [0x5],
        'inc': [0x6],
        'isz': [0x7],
        'add': [0x8],
        'sub': [0x9],
        'ld' : [0xA],
        'xch': [0xB],
        'bll': [0xC],
        'ldm': [0xD],
        'wrm': [0xE, 0x0],
        'wmp': [0xE, 0x1],
        'wrr': [0xE, 0x2],
        'wpm': [0xE, 0x3],
        'wr0': [0xE, 0x4],
        'wr1': [0xE, 0x5],
        'wr2': [0xE, 0x6],
        'wr3': [0xE, 0x7],
        'sbm': [0xE, 0x8],
        'rdm': [0xE, 0x9],
        'rdr': [0xE, 0xA],
        'adm': [0xE, 0xB],
        'rd0': [0xE, 0xC],
        'rd1': [0xE, 0xD],
        'rd2': [0xE, 0xE],
        'rd3': [0xE, 0xF],
        'clb': [0xF, 0x0],
        'clc': [0xF, 0x1],
        'iac': [0xF, 0x2],
        'cmc': [0xF, 0x3],
        'cma': [0xF, 0x4],
        'ral': [0xF, 0x5],
        'rar': [0xF, 0x6],
        'tcc': [0xF, 0x7],
        'dac': [0xF, 0x8],
        'tcs': [0xF, 0x9],
        'stc': [0xF, 0xA],
        'daa': [0xF, 0xB],
        'kbp': [0xF, 0xC],
        'dcl': [0xF, 0xD],
        }

# instructions that take a
instr_hex = ['jcn', 'inc', 'isz', 'add', 'sub', 'ld', 'xch', 'bll', 'ldm']

# instructions that are 16-bit and dont address 12-bits
instr_dos = ['jcn', 'fim', 'isz']

# shortened versions of jcn
instr_short = ['jnt', 'jc', 'jz', 'jt', 'jnc', 'jnz']

# instructions that address a pair
instr_ev = ['fim', 'src', 'fin', 'jin']

# instructions that take in data
instr_data = ['ldm', 'bbl']

# instructions that are 16-bit and do address 12-bits
instr_jump = ['jun', 'jms']

# unsupported instructions
instr_unsupported = ['wpm']

# list of registers
reg_list = ['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15', 'p0', 'p1', 'p2', 'p3', 'p4', 'p5', 'p6', 'p7']

symbols = {}

####################################################################################################
####################################################################################################

# Returns the hex value of a register given the register string
def reg_to_hex(reg):
    if (reg not in reg_list):
        print(reg, "is not a register")
        exit(1)

    if 'r' in reg:
        return int(reg.replace('r',''))
    elif 'p' in reg:
        return (int(reg.replace('p','')) << 1)

def symbol_to_hex(sym):
    try:
        return int(sym)
    except:
        pass

    if isinstance(sym, int):
        return sym
    if "0x" in str(sym):
        if int(str(sym).replace("0x",""), 16) > 0xFFF:
            print("Warning,", sym, "may be too large")
        return int(str(sym).replace("0x",""), 16)
    elif "#" in str(sym):
        if int(str(sym).replace("#",""), 10) > 4095:
            print("Warning,", sym, "may be too large")
        return int(str(sym).replace("#",""), 10)
    else:
        return symbols[sym]

def parse_symbol(line):
    inst = line.replace(",", "").split(' ')
    try:
        dec = instr[inst[0]][:]
    except:
        return inst[0]
    if inst[0] in instr_dos or inst[0] in instr_jump or inst[0] in instr_short:
        return [-1, -1]
    else:
        return [-1]

def parse_line(line):
    inst = line.replace(",", "").split(' ')
    try:
        dec = instr[inst[0]][:]
    except:
        return inst[0]

    if len(dec) == 1 and inst[0] in instr_data:
        dec = [(dec[0] << 4) + int(inst[1])]
    elif len(dec) == 1 and inst[0] in instr_jump:
        dec = [(dec[0] << 4) + (int(symbol_to_hex(inst[1])) >> 8)]
    elif len(dec) == 2:
        dec = [(dec[0] << 4) + symbol_to_hex(dec[1])]
    elif len(dec) == 1 and inst[0] in instr_ev:
        dec = [(dec[0] << 4) + ((reg_to_hex(inst[1]) >> 1) << 1)]
    else:
        dec = [(dec[0] << 4) + reg_to_hex(inst[1])]

    if inst[0] in ['jin', 'src']:
        dec[0] += 1

    if inst[0] in instr_unsupported:
        print(line, " is unsupported on the 4004")
        exit(1)

    if inst[0] in instr_dos:
        try:
            dec.append(symbol_to_hex(inst[2]))
        except:
            print("Hex location required: ", line)
            exit(1)

    elif inst[0] in instr_short:
        try:
            dec.append(symbol_to_hex(inst[1]))
        except:
            print("Hex location required: ", line)
            exit(1)

    elif inst[0] in instr_jump:
        try:
            dec.append(symbol_to_hex(inst[1])%256)
        except:
            print("Hex location required: ", line)
            exit(1)

    try:
        return bytes(dec)
    except:
        print(dec, " is too large!")
        exit(1)

####################################################################################################
####################################################################################################

parser = argparse.ArgumentParser(description='Assembler for Intel 4004 Processor')
parser.add_argument('-i', '--input', help='Input file', required=True)
parser.add_argument('-o', '--output', help='Output file')
parser.add_argument('-v', '--verbose', action='store_true')
parser.add_argument('--line', help='Print out lines surrounding hex location in binary file')
parser.add_argument('--surr', help='Number of surrounding lines for --line', type=int, default=2)

args = parser.parse_args()

if args.output is None:
    args.output = ".".join(args.input.split(".")[:-1]) + ".bin"

if args.line is not None:
    args.line = int(args.line, 16)

if args.verbose:
    print()
    print("Input file:", args.input)
    print("Output file:", args.output)

try:
    input_file = open(args.input, 'r')
except:
    print("Unable to open file: ", args.input)
    exit(1)

try:
    output_file = open(args.output, 'wb')
except:
    print("Unable to open file: ", args.output)
    exit(1)

text = input_file.read().lower().split('\n')[:-1]

# remove blank lines
text = [x for x in text if x != '']

rom_pos = 0x0

if args.verbose:
    print()

# First pass to check symbols
for line in text[:]:
    line = line.split(';')[0].lstrip()
    if line.replace(" ","") == '':
        continue

    parsed = parse_symbol(line)
    if isinstance(parsed, str):
        symbols[parsed] = rom_pos
        continue
    else:
        rom_pos += len(parsed)

if args.verbose:
    print("symbols: ", symbols)
    print()

rom_pos = 0x0

code = []

# Second pass to translate
for line in text[:]:

    # Remove comments and skip empty lines
    line = line.split(';')[0].lstrip()
    if line.replace(" ","") == '':
        continue

    parsed = parse_line(line)

    if isinstance(parsed, str):
        if args.verbose or (args.line is not None and (rom_pos >= args.line - args.surr and rom_pos <= args.line + args.surr)):
            print("\t", parsed)
        continue

    if args.verbose or (args.line is not None and (rom_pos >= args.line - args.surr and rom_pos <= args.line + args.surr)):
        if len(parsed) == 2:
            print(" \033[31m$"f"{(rom_pos%2**16):03X}\033[0m", "\t\033[36m", parsed.hex()[:2], parsed.hex()[2:], "\033[0m\t", line)
        else:
            print(" \033[31m$"f"{(rom_pos%2**16):03X}\033[0m", "\t\033[36m", parsed.hex(), "\033[0m\t", line)

    rom_pos += len(parsed)

    if rom_pos > 2**8:
        print("ROM too large!")
        print(rom_pos, " / 256 instructions")
        exit(1)

    code.append(parsed.hex())
    output_file.write(parsed)

if args.verbose:
    print()
    print("".join(code))
    print()
